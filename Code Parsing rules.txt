Scenario are split into TEXT files and DATA files.
The DATA files contain the flow of the TEXT files.

In the DATA files we are defining scenarios like this:
-- *01
-- DisplayMessage 00
-- DisplayMessage 01
-- DisplayMessage 02
-- ...
-- DisplayMessage 44
-- DisplayMessage 45
-- IfLe 15 2e 04
-- Jump 02 22 01
-- Jump 02 23 01
-- End20

DisplayMessage invoked the text block from the TEXT file.
End20 probably serves as a return function or end funtion. Need to check.

In TEXT files there are TextBlocks that are defined:
-- *00
-- ...
-- ...
-- EndTextBlk

EndTextBlk serves as the end of a block. Basically a return command in renpy.

in renpy converted files i think the best way to keep the same scheme would be to use global and local labels.

A global label would hold local labels based on the DATA files.

---------------------------------------------------------------------------

-- Text "{Message}"
-- WaitKey
-- NewLine

This block will display a text - game doesn't display who is speaking

Example:
-- Text "「わーってるよ！」"
-- WaitKey
-- NewLine

WaitPage - this is probablt the equivelent of nvl clear in renpy - it will display every line until a new page should be shown where it should be cleared.
WaitKey - This probably waits for key input - in renpy this wont be parsed
Wait - this is a function to wait until the specified ammount. in the lvns it probably is tied to gramerate.
NewLine probably is an explicit command to print the characters in a new line and if not added it will print characters in the last cursor position. Need to check.

----------------------------------------------------------------------------------------

-- Text "「ふぅ、ふぅ…。"
-- WaitKey
-- SayNameD8
-- SayNameD9
-- SayNameDA
-- SayNameDB
-- SayNameDC
-- SayNameDD
-- Text "ちゃん、お願いだから、寝坊しないで」"
-- WaitKey

SayNameD{NUMBER} - Probably prints a name
----------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------
BGM specific commands
StartBGM - Play a bgm music
FadeBGM - I assume this would FadeOut the music
FadeInBGM - This is a setting for FadeIn music
PauseBGM - Causes the bgm to stop.
WaitForFadeBGM - Waits until the bgm is Faded (to value 0)
SetNextBGM - When a song is playing and looping it will set the next song to be played also in a loop. That's how I assume it works.

SFX specific commands
LoadPCM - Loads the sound into the memory. With renpy this isn't nedded.
StopPCM - As the name suggest it stops the sound, but I am not sure for what. The sounds are small and don't appear to be looping.
StartPCM - Plays the sound.
WaitPCM - Waits for the sound to complete. This probably is useful for playing specific landmark sounds that shouldnt be skipped.

Renpy Sound Implementation:
-- play music "mozart.ogg" => StartBGM
-- play sound "woof.mp3" => StartPCM
-- stop music fadeout 1.0 => FadeBGM + WaitForFadeBGM + PauseBGM
-- stop sound => StopPCM
-- #TODO: Add renpy specific wait function for music completion. Preferably with a modal screen so the user can't skip interaction.

BGM and SFX will be hardcoded for the purpose of code integrity.

FLAG SYSTEM:

In renpy i will make it into a dictionary where a hex name will have an int value to manipulate

FlagAdd (and FlagAdd62) - Add specified ammount to the selected flag.
FlagSub                 - Substract specified ammount to the selected flag.
SetFlag                 - Sets the flag to the value
FlagSetBit              - #TODO

Comparing functions:
x = current value | y = second value to compare
IfEq        - if its equal                 x == y  
IfNe        - if its not equal             x != y  
IfGt        - if its greater               x > y   
IfLe        - if its lower                 x < y   
IfGte       - if its greater or equal      x >= y  
IfLte       - if its smaller or equal      x =< y  
IfBitOn     - #TODO
IfBitOff    - #TODO

It's genius. So the If statements as they do they check if the statement is true.
If its true it would skip the specified bytes to the next space.
Example:
*07
StartBGM 05
Push2D 00 20 08
IfNe 1e 03 0c       # if the statement is true it will skip 0c bytes (12 positions)
IfLe 14 0e 08       # This command will be executed if the if statement returned False
IfGte ae 05 04
Jump 01 43 01
IfLe ab 2e 10       # It will jump to here if it was true
IfNe 1e 07 0c
IfLe 14 1e 08
IfGte ae 05 04
Jump 01 47 01
IfNe ab 3f 0c       # Then here and so on...
IfNe 0c 3f 08
IfLe 17 16 04
Jump 04 54 01

it seems that if statements are used as multiple check
When an if statement is followed by an if statement then they should be evaluated together (&)
Any command that folows an if statement is the command that should be executed if the statement is true
it doesnt appear to have else statements so after executing the if statement if true then it will go to the next command unless a jump command was used.

#TODO: Jump command is confussing. In most of the times it looks like a simple jump but also like it actually returns like calling a label in renpy




DisplayMessage - this is used as calling a label because we expect to get back to that point of execution. It will return with EndTextBlk
JumpBlk - This command is used to jump inside the DATA file. It will return based on End20.
Jump - is used to jump between DATA files and DATA block. We specify the 2 hex value (0a 87 => filename) and the third is the block to execute. It also returns of End20.
SameBlkJump - thats a very weird jump... It will jump into an incremented scenario in DATA file. So when the current scenario would be 2 and the command has 10 as a parrametter then the jump would go to the 12 block inside the DATA file. Why? But this does not work with some scenario files... Maybe it introduces some shifting in the current block? like adding just jumping a line ahead. It is only used in DATA files so it's confusing. For the most uses that exists it matches the idea of jumping to a scenario block. Only one doesn't match as a scenarion block doesnt exist with the specified number...
#TODO: I will have to create a json tree for explaining every command and path that is possible with the scripts.

Example:
*0a
IfNe ad 06 01
Return2D
IfNe ab 3d 08
IfNe 24 06 04
Jump 07 55 01
IfNe ab 3e 08
IfNe 24 08 04
Jump 07 5a 01
Return2D
End20

#TODO: Nazo messages
Nazo23 0x23
Nazo26 0x26
Nazo27 0x27
Nazo40 0x40
Nazo44 0x44
Nazo50 0x50
Nazo6B 0x6b
Nazo6C 0x6c
Nazo70 0x70
Nazo71 0x71
Nazo72 0x72
Nazo74 0x74
Nazo75 0x75
Nazo76 0x76
Nazo79 0x79
Nazo7A 0x7a
NazoPCMA6 0xa6
NazoPCMA7 0xa7
NazoPCMA8 0xa8
NazoB4 0xb4
NazoB8 0xb8
NazoBA 0xba
NazoBE 0xbe
NazoC7 0xc7
NazoC9 0xc9
NazoCC 0xcc
NazoCF 0xcf
NazoF8 0xf8